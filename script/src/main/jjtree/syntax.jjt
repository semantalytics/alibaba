options {
	MULTI=true;
	VISITOR=true;
	STATIC=false;
	UNICODE_INPUT=true;
	JAVA_UNICODE_ESCAPE=true; // pre-process unicode escapes, see section A.2 of spec
	TRACK_TOKENS=true;
}

PARSER_BEGIN(SyntaxTreeBuilder)

package org.openrdf.marple.ast;

import java.io.StringReader;

public class SyntaxTreeBuilder {

	public static ASTBody parse(String code) throws TokenMgrError,
			ParseException {
		return new SyntaxTreeBuilder(new StringReader(code)).Body();
	}
}

PARSER_END(SyntaxTreeBuilder)
//
// tokens
//

TOKEN :
{
	// Whitespace characters
	<#WS_CHAR: " " | "\t" | "\n" | "\r" | "\f">
}

SKIP :
{
	<WHITESPACE: <WS_CHAR>>
}

SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT: "#" (~["\n","\r"])*>
}

// Special characters
TOKEN :
{
	<PIPE: "|">
|	<LPAREN: "(">
|	<RPAREN: ")">
|	<LBRACE: "{">
|	<RBRACE: "}">
|	<LBRACK: "[">
|	<RBRACK: "]">
|	<SEMICOLON: ";">
|	<COMMA: ",">
|	<DOT: ".">
|	<ASSIGN: ":=">
|	<EQ: "=">
|	<NE: "!=">
|	<GT: ">">
|	<LT: "<">
|	<LE: "<=">
|	<GE: ">=">
|	<OR: "||">
|	<AND: "&&">
|	<PLUS: "+">
|	<MINUS: "-">
|	<STAR: "*">
|	<SLASH: "/">
|	<BANG: "!">
|	<CARRET: "^">
|	<SEND: "<-">
|	<DT_PREFIX: "^^">
|	<ANON: <LBRACK> (<WS_CHAR>)* <RBRACK>>
}

TOKEN :
{
	<A: "a"> // Note: case-sensitive!
}

TOKEN [IGNORE_CASE] :
{
	<BASE: "base">
|	<PREFIX: "prefix">
|	<DO: "do">
|	<RESCUE: "rescue">
|	<ENSURE: "ensure">
|	<END: "end">
|	<OPTIONAL: "optional">
|	<GRAPH: "graph">
|	<UNION: "union">
|	<FILTER: "filter">
|	<TRUE: "true">
|	<FALSE: "false">
}

TOKEN:
{
	<Q_IRI_REF: "<" (~["<", ">", "\"", "{", "}", "|", "^", "`", "\\", "\u0000"-"\u0020"])* ">">

|	<KEYWORD: ("@")? (<PN_PREFIX>)+>
|	<PNAME_NS: (<PN_PREFIX>)? ":">
|	<PNAME_LN: (<PN_PREFIX>)? ":" <PN_LOCAL>> // Note: PN_LOCAL not optional, case handled by PNAME_NS

|	<BLANK_NODE_LABEL: "_:" <PN_LOCAL>>

|	<BINDING_VAR: "?" <VARNAME>>
|	<BOUND_VAR: "$" <VARNAME>>
|	<LANGTAG: "@" (<ALPHA>)+ ("-" (<ALPHA>|<NUM>)+)*>
|	<RANGE: "..">
|	<INTEGER: (<NUM>)+>
|	<INTEGER_POSITIVE: "+" <INTEGER>>
|	<INTEGER_NEGATIVE: "-" <INTEGER>>
|	<DECIMAL: (<DECIMAL1>|<DECIMAL2>)>
|	<#DECIMAL1: (<NUM>)+ "." (<NUM>)+>
|	<#DECIMAL2: "." (<NUM>)+>
|	<DECIMAL_POSITIVE: "+" <DECIMAL>>
|	<DECIMAL_NEGATIVE: "-" <DECIMAL>>
|	<DOUBLE: (<DOUBLE1>|<DOUBLE2>|<DOUBLE3>)>
|	<#DOUBLE1: (<NUM>)+ "." (<NUM>)+ <EXPONENT>>
|	<#DOUBLE2: "." (<NUM>)+ <EXPONENT>>
|	<#DOUBLE3: (<NUM>)+ <EXPONENT>>
|	<#EXPONENT: ["e","E"] (["+","-"])? (<NUM>)+>
|	<DOUBLE_POSITIVE: "+" <DOUBLE>>
|	<DOUBLE_NEGATIVE: "-" <DOUBLE>>
|	<STRING_LITERAL1: "'" (<SAFE_CHAR1>|<ECHAR>)* "'">
|	<STRING_LITERAL2: "\"" (<SAFE_CHAR2>|<ECHAR>)* "\"">
|	<STRING_LITERAL_LONG1: "'''" ( ("'"|"''")? (<SAFE_CHAR_LONG1>|<ECHAR>) )* "'''">
|	<STRING_LITERAL_LONG2: "\"\"\"" ( ("\""|"\"\"")? (<SAFE_CHAR_LONG2>|<ECHAR>) )* "\"\"\"">
|	<#SAFE_CHAR1: (~["'", "\\", "\r", "\n"])>
|	<#SAFE_CHAR2: (~["\"", "\\", "\r", "\n"])>
|	<#SAFE_CHAR_LONG1: (~["'","\\"])>
|	<#SAFE_CHAR_LONG2: (~["\"","\\"])>
|	<#ECHAR: "\\" ["t", "b", "n", "r", "f", "\\", "\"", "'"]>
|	<#HEX: ["0"-"9"] | ["A"-"F"] | ["a"-"f"]>
|	<#ALPHA: ["a"-"z","A"-"Z"]>
|	<#NUM: ["0"-"9"]>
}

TOKEN:
{
	<#PN_CHARS_BASE:
	    <ALPHA> | ["\u00C0"-"\u00D6"] | ["\u00D8"-"\u00F6"] | ["\u00F8"-"\u02FF"] | ["\u0370"-"\u037D"]
	  | ["\u037F"-"\u1FFF"] | ["\u200C"-"\u200D"] | ["\u2070"-"\u218F"] | ["\u2C00"-"\u2FEF"]
	  | ["\u3001"-"\uD7FF"] | ["\uF900"-"\uFDCF"] | ["\uFDF0"-"\uFFFD"]
	  // | ["\u10000"-"\uEFFFF"] FIXME: JavaCC/Java can't handle this?
	>
|	<#PN_CHARS_U: <PN_CHARS_BASE> | "_">
|	<#PN_START_CHAR: <PN_CHARS_U> | <NUM>>
|	<#VAR_CHAR: <PN_START_CHAR> | "\u00B7" | ["\u0300"-"\u036F"] | ["\u203F"-"\u2040"]>
|	<#PN_END_CHAR: <VAR_CHAR> | "-">
|	<#PN_CHAR: <PN_END_CHAR> | ".">

|	<#PN_PREFIX: <PN_CHARS_BASE> ( (<PN_CHAR>)* <PN_END_CHAR> )?>
|	<#PN_LOCAL: <PN_START_CHAR> ( (<PN_CHAR>)* <PN_END_CHAR> )?>
|	<#VARNAME: <PN_START_CHAR> (<VAR_CHAR>)*>
}

//
// grammar
//

ASTBody Body(): {}
{
  Prolog()
  [Statements()]
  <EOF>
  { return jjtThis; }
}

void Prolog() #void : {}
{
	[ BaseDecl() ] ( PrefixDecl() )*
}

void BaseDecl(): {} 
{
	<BASE> IRI() <DOT>
}

void PrefixDecl(): { Token t; }
{
	<PREFIX> t = <PNAME_NS> IRI() <DOT>
	{jjtThis.jjtSetValue(t.image);}
}

void Statements() : {}
{
	// Note: recursive rule rewriten to non-recursive rule, requires lookahead
	Expression() ( LOOKAHEAD(2) <DOT> Expression() )* [<DOT>]
}

void Expression() #void : {}
{
	LOOKAHEAD(2) Assignment()
|	ConditionalOrExpression()
}

void Assignment(): {}
{
	BoundVar() <ASSIGN> Expression()
}

void BlockExpression(): {}
{
	<DO> [BindingSet()] [Statements()]
	[Rescue()]
	[Ensure()]
	<END>
}

void BindingSet(): {}
{
	<PIPE> (BoundVar())+ <PIPE>
}

void Rescue(): {}
{
	<RESCUE> <PIPE> BoundVar() <PIPE> Statements()
}

void Ensure(): {}
{
	<ENSURE> Statements()
}

void ConditionalOrExpression() : {}
{
	ConditionalAndExpression() [ <OR> ConditionalOrExpression() #Or(2) ]
}

void ConditionalAndExpression() : {}
{
	ValueLogical() [ <AND> ConditionalAndExpression() #And(2) ]
}

void ValueLogical() #void : {}
{
	RelationalExpression()
}

void RelationalExpression() : {}
{
	ControlExpression()
	[
		<EQ> ControlExpression()
	|	<NE> ControlExpression()
	|	<LT> ControlExpression()
	|	<LE> ControlExpression()
	|	<GE> ControlExpression()
	|	<GT> ControlExpression()
	]
}

void ControlExpression() #void : {}
{
	LOOKAHEAD(2) Control()
|	AdditiveExpression()
}

void AdditiveExpression() #void : {}
{
	MultiplicativeExpression()
	(
	  <PLUS> MultiplicativeExpression()
	| <MINUS> MultiplicativeExpression()
	| NumericLiteralPositive()
	| NumericLiteralNegative()
	)*
}

void MultiplicativeExpression() #void : {}
{
	UnaryExpression()
	(
	  <STAR> UnaryExpression()
	| <SLASH> UnaryExpression()
	)*
}

void UnaryExpression(): {}
{
	(<BANG> | <MINUS> | [<PLUS>])
	(LOOKAHEAD(2) Function() | ValueList())
}

void Control(): {}
{
	ConstantIRI() ValueList() (ConstantIRI() ValueList())*
}

void Function(): {}
{
	ConstantIRI() <LPAREN> [ValueList()] <RPAREN>
}

void ValueList(): {}
{
	Value() ( <COMMA> Value() )*
}

void Value(): {}
{
	Object()
|	GraphPattern() [Message()]
|	BlockExpression() [Message()]
}

void Object(): {}
{
	Var() [ResourceTail()]
|	IRIref() [ResourceTail()]
|	RDFLiteral() [ValueTail()]
|	NumericLiteral() [ValueTail()]
|	BooleanLiteral() [ValueTail()]
|	BlankNode() [ResourceTail()]
|	ResourceTemplate() [ResourceTail()]
|	BrackettedExpression() [ValueTail()]
}

void Verb(): {}
{
	Keyword() [ResourceTail()]
|	Var() [ResourceTail()]
|	IRIref() [ResourceTail()]
|	RDFLiteral() ValueTail()
|	NumericLiteral() ValueTail()
|	BooleanLiteral() ValueTail()
|	BlankNode() ResourceTail()
|	ResourceTemplate() ResourceTail()
|	BrackettedExpression() [ValueTail()]
}

void BrackettedExpression() #void : {}
{
	<LPAREN> Expression() <RPAREN>
}

void ResourceTail() #void : {}
{
	Traversal() | ValueTail()
}

void ValueTail() #void : {}
{
	ReverseTraversal() | Message()
}

void Traversal(): {}
{
	<BANG> ConstantIRI() [ResourceTail()]
}

void ReverseTraversal(): {}
{
	<CARRET> ConstantIRI() [ResourceTail()]
}

void Message(): {}
{
	<SEND> ConstantIRI() <LPAREN> [LOOKAHEAD(2) MessageList() | ValueList()] <RPAREN> [ResourceTail()]
}

void MessageList(): {}
{
	ConstantIRI() ValueList() (ConstantIRI() ValueList())*
}

void ConstantIRI() #void : {}
{
	IRIref() | Keyword()
}

void Keyword(): {}
{
	<KEYWORD> | <A>
}

void Var() #void : {}
{
	BoundVar() | BindingVar()
}

void BindingVar(): {}
{
	<BINDING_VAR>
}

void BoundVar(): {}
{
	<BOUND_VAR>
}

void BlankNode(): {}
{
	<BLANK_NODE_LABEL> | <ANON>
}

void GraphPattern(): {}
{
	<LBRACE> GraphPatternExpressions() <RBRACE>
}

void GraphPatternExpressions() #void : {}
{
	[BasicGraphPattern()] [ GraphPatternNotTriples() [<DOT>] GraphPatternExpressions() ]
}

void GraphPatternNotTriples() #void : {}
{
	OptionalGraphPattern()
|	GroupOrUnionGraphPattern()
|	GraphGraphPattern()
}

void BasicGraphPattern(): {}
{
	TriplesBlock() ( Filter() [<DOT>] [TriplesBlock()] )*
|	( Filter() [<DOT>] [TriplesBlock()] )+
}

void Filter(): {}
{
	<FILTER> BrackettedExpression()
}

void TriplesBlock() #void : {}
{
	// Note: recursive rule rewriten to non-recursive rule, requires lookahead
	TriplesSameSubject() ( LOOKAHEAD(2) <DOT> TriplesSameSubject() )* [<DOT>]
}

void TriplesSameSubject(): {}
{
	Object() [PropertyList()]
}

void OptionalGraphPattern(): {}
{
	// Note: does not refer GraphPattern() because constraints are not limited
	// to the optional graph pattern, but can also reference the operator's LHS
	<OPTIONAL> <LBRACE> GraphPatternExpressions() <RBRACE>
}

void GroupOrUnionGraphPattern(): {}
{
	GraphPattern() [ <UNION> GroupOrUnionGraphPattern() ]
}

void GraphGraphPattern(): {}
{
	<GRAPH> Verb() GraphPattern()
}

void ResourceTemplate(): {}
{
	<LBRACK> PropertyList() <RBRACK>
}

void PropertyList(): {}
{
	Verb() ObjectList() [ <SEMICOLON> [PropertyList()] ]
}

void ObjectList(): {}
{
	Object() ( <COMMA> Object() )*
}

void IRIref() #void : {}
{
	IRI() | PrefixedName()
}

void IRI(): {}
{
	<Q_IRI_REF>
}

void PrefixedName(): {}
{
	<PNAME_LN> | <PNAME_NS>
}

void RDFLiteral(): {}
{
	String() [<LANGTAG> | <DT_PREFIX> IRIref() ]
}

void NumericLiteral() #void : {}
{
	NumericLiteralUnsigned()
|	NumericLiteralPositive()
|	NumericLiteralNegative()
}

void NumericLiteralUnsigned(): {}
{
	<INTEGER>
|	<DECIMAL>
|	<DOUBLE>
}

void NumericLiteralPositive(): {}
{
	<INTEGER_POSITIVE>
|	<DECIMAL_POSITIVE>
|	<DOUBLE_POSITIVE>
}

void NumericLiteralNegative(): {}
{
	<INTEGER_NEGATIVE>
|	<DECIMAL_NEGATIVE>
|	<DOUBLE_NEGATIVE>
}

void BooleanLiteral(): {}
{
	<TRUE> | <FALSE>
}

void String(): {}
{
	<STRING_LITERAL1>
|	<STRING_LITERAL2>
|	<STRING_LITERAL_LONG1>
|	<STRING_LITERAL_LONG2>
}
